name: Deploy Frontend to Elastic Beanstalk

on:
  push:
    branches: [main]
    paths:
      - 'web/energy-dashboard/**'
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  EB_APP_NAME: energy-dashboard-frontend
  EB_ENV_NAME: energy-dashboard-frontend-env
  S3_BUCKET: energy-dashboard-deployments
  # Required IAM roles
  SERVICE_ROLE: aws-elasticbeanstalk-service-role
  INSTANCE_PROFILE: aws-elasticbeanstalk-ec2-role

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Build Frontend (Linux amd64)
        working-directory: web/energy-dashboard
        env:
          CGO_ENABLED: 0
          GOOS: linux
          GOARCH: amd64
        run: |
          go mod tidy
          go build -o energy-dashboard-go ./main.go
          ls -lh energy-dashboard-go

      - name: Zip Frontend Application
        working-directory: web/energy-dashboard
        run: |
          zip -r frontend-app.zip \
            energy-dashboard-go \
            Procfile \
            templates/ \
            static/ \
            -x "*.git*" "*.env*"
          ls -lh frontend-app.zip

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure S3 bucket exists
        run: |
          if ! aws s3 ls "s3://${{ env.S3_BUCKET }}" >/dev/null 2>&1; then
            aws s3 mb "s3://${{ env.S3_BUCKET }}" --region "${{ env.AWS_REGION }}"
          fi

      - name: Upload Frontend to S3
        working-directory: web/energy-dashboard
        run: |
          aws s3 cp frontend-app.zip "s3://${{ env.S3_BUCKET }}/frontend-app.zip" --region "${{ env.AWS_REGION }}"

      - name: Create EB Application (if needed)
        run: |
          if [ "$(aws elasticbeanstalk describe-applications \
                --application-names "${{ env.EB_APP_NAME }}" \
                --query 'length(Applications)' \
                --output text 2>/dev/null)" = "0" ]; then
            aws elasticbeanstalk create-application \
              --application-name "${{ env.EB_APP_NAME }}" \
              --region "${{ env.AWS_REGION }}"
          fi

      - name: Create EB Application Version
        run: |
          VERSION_LABEL="v1-$(date +%Y%m%d%H%M%S)"
          echo "Using version: $VERSION_LABEL"
          aws elasticbeanstalk create-application-version \
            --application-name "${{ env.EB_APP_NAME }}" \
            --version-label "$VERSION_LABEL" \
            --source-bundle S3Bucket="${{ env.S3_BUCKET }}",S3Key=frontend-app.zip \
            --region "${{ env.AWS_REGION }}"
          echo "VERSION_LABEL=$VERSION_LABEL" >> "$GITHUB_ENV"

      - name: Resolve EB Platform ARN (Go on AL2023)
        run: |
          echo "Searching for Go platform on AL2023..."
          
          # Try to find the latest Go platform on AL2023
          PLATFORM_ARN=$(aws elasticbeanstalk list-platform-versions \
            --region "${{ env.AWS_REGION }}" \
            --query "reverse(sort_by(PlatformSummaryList[?contains(PlatformBranchName, 'Go') && contains(PlatformBranchName, '2023')], &PlatformVersion))[0].PlatformArn" \
            --output text 2>&1)

          echo "Query result: '$PLATFORM_ARN'"

          # Check if the result is empty, "None", or "null"
          if [ -z "$PLATFORM_ARN" ] || [ "$PLATFORM_ARN" = "None" ] || [ "$PLATFORM_ARN" = "null" ]; then
            echo "❌ Failed to resolve AL2023 Go platform ARN"
            echo ""
            echo "Available Go platforms:"
            aws elasticbeanstalk list-platform-versions \
              --region "${{ env.AWS_REGION }}" \
              --query "PlatformSummaryList[?contains(PlatformBranchName, 'Go')].{Name:PlatformBranchName,Version:PlatformVersion,ARN:PlatformArn}" \
              --output table
            echo ""
            echo "Trying fallback: any available Go platform..."
            
            # Fallback to any Go platform
            PLATFORM_ARN=$(aws elasticbeanstalk list-platform-versions \
              --region "${{ env.AWS_REGION }}" \
              --query "reverse(sort_by(PlatformSummaryList[?contains(PlatformBranchName, 'Go')], &PlatformVersion))[0].PlatformArn" \
              --output text)
            
            if [ -z "$PLATFORM_ARN" ] || [ "$PLATFORM_ARN" = "None" ] || [ "$PLATFORM_ARN" = "null" ]; then
              echo "❌ No Go platform found at all"
              exit 1
            fi
          fi
          
          echo "✅ Using platform: $PLATFORM_ARN"
          echo "PLATFORM_ARN=$PLATFORM_ARN" >> "$GITHUB_ENV"

      - name: Check/Create IAM Instance Profile
        run: |
          # Check if instance profile exists
          if ! aws iam get-instance-profile --instance-profile-name "${{ env.INSTANCE_PROFILE }}" >/dev/null 2>&1; then
            echo "Creating IAM role and instance profile..."
            
            # Create the role
            aws iam create-role \
              --role-name "${{ env.INSTANCE_PROFILE }}" \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [{
                  "Effect": "Allow",
                  "Principal": {"Service": "ec2.amazonaws.com"},
                  "Action": "sts:AssumeRole"
                }]
              }' || true
            
            # Attach managed policies
            aws iam attach-role-policy \
              --role-name "${{ env.INSTANCE_PROFILE }}" \
              --policy-arn arn:aws:iam::aws:policy/AWSElasticBeanstalkWebTier || true
            
            aws iam attach-role-policy \
              --role-name "${{ env.INSTANCE_PROFILE }}" \
              --policy-arn arn:aws:iam::aws:policy/AWSElasticBeanstalkWorkerTier || true
            
            aws iam attach-role-policy \
              --role-name "${{ env.INSTANCE_PROFILE }}" \
              --policy-arn arn:aws:iam::aws:policy/AWSElasticBeanstalkMulticontainerDocker || true
            
            # Create instance profile
            aws iam create-instance-profile \
              --instance-profile-name "${{ env.INSTANCE_PROFILE }}" || true
            
            # Add role to instance profile
            aws iam add-role-to-instance-profile \
              --instance-profile-name "${{ env.INSTANCE_PROFILE }}" \
              --role-name "${{ env.INSTANCE_PROFILE }}" || true
            
            echo "Waiting for IAM propagation..."
            sleep 10
          else
            echo "✅ Instance profile already exists"
          fi

      - name: Check/Create Service Role
        run: |
          if ! aws iam get-role --role-name "${{ env.SERVICE_ROLE }}" >/dev/null 2>&1; then
            echo "Creating service role..."
            
            aws iam create-role \
              --role-name "${{ env.SERVICE_ROLE }}" \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [{
                  "Effect": "Allow",
                  "Principal": {"Service": "elasticbeanstalk.amazonaws.com"},
                  "Action": "sts:AssumeRole",
                  "Condition": {
                    "StringEquals": {
                      "sts:ExternalId": "elasticbeanstalk"
                    }
                  }
                }]
              }' || true
            
            aws iam attach-role-policy \
              --role-name "${{ env.SERVICE_ROLE }}" \
              --policy-arn arn:aws:iam::aws:policy/service-role/AWSElasticBeanstalkEnhancedHealth || true
            
            aws iam attach-role-policy \
              --role-name "${{ env.SERVICE_ROLE }}" \
              --policy-arn arn:aws:iam::aws:policy/AWSElasticBeanstalkManagedUpdatesCustomerRolePolicy || true
            
            sleep 10
          else
            echo "✅ Service role already exists"
          fi

      - name: Check/Create EB Environment
        run: |
          EXISTING_ENV=$(
            aws elasticbeanstalk describe-environments \
              --application-name "${{ env.EB_APP_NAME }}" \
              --environment-names "${{ env.EB_ENV_NAME }}" \
              --query 'Environments[?Status!=`Terminated`].EnvironmentName' \
              --output text \
              --region "${{ env.AWS_REGION }}"
          )

          if [ -z "$EXISTING_ENV" ]; then
            echo "Creating new environment with IAM roles..."
            
            # Get account ID for ARN construction
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            
            aws elasticbeanstalk create-environment \
              --application-name "${{ env.EB_APP_NAME }}" \
              --environment-name "${{ env.EB_ENV_NAME }}" \
              --platform-arn "${{ env.PLATFORM_ARN }}" \
              --version-label "${{ env.VERSION_LABEL }}" \
              --option-settings \
                Namespace=aws:autoscaling:launchconfiguration,OptionName=IamInstanceProfile,Value="${{ env.INSTANCE_PROFILE }}" \
                Namespace=aws:elasticbeanstalk:environment,OptionName=ServiceRole,Value="arn:aws:iam::${ACCOUNT_ID}:role/${{ env.SERVICE_ROLE }}" \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=API_URL,Value=http://smart-energy-grid-env.eba-qgkwbhh7.us-east-1.elasticbeanstalk.com \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=PORT,Value=3000 \
              --region "${{ env.AWS_REGION }}"

            echo "Waiting for environment to be created..."
            aws elasticbeanstalk wait environment-exists \
              --application-name "${{ env.EB_APP_NAME }}" \
              --environment-names "${{ env.EB_ENV_NAME }}" \
              --region "${{ env.AWS_REGION }}"
          else
            echo "✅ Environment already exists: ${EXISTING_ENV}"
          fi

      - name: Deploy Frontend to Elastic Beanstalk
        run: |
          aws elasticbeanstalk update-environment \
            --application-name "${{ env.EB_APP_NAME }}" \
            --environment-name "${{ env.EB_ENV_NAME }}" \
            --version-label "${{ env.VERSION_LABEL }}" \
            --region "${{ env.AWS_REGION }}"

      - name: Wait for Deployment
        run: |
          echo "Waiting for environment to be ready..."
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            status=$(aws elasticbeanstalk describe-environments \
              --application-name "${{ env.EB_APP_NAME }}" \
              --environment-names "${{ env.EB_ENV_NAME }}" \
              --region "${{ env.AWS_REGION }}" \
              --query 'Environments[0].Status' --output text)
            
            health=$(aws elasticbeanstalk describe-environments \
              --application-name "${{ env.EB_APP_NAME }}" \
              --environment-names "${{ env.EB_ENV_NAME }}" \
              --region "${{ env.AWS_REGION }}" \
              --query 'Environments[0].Health' --output text)
            
            echo "Status: $status, Health: $health"
            
            if [ "$status" = "Ready" ] && [ "$health" = "Green" ]; then
              echo "✅ Deployment successful!"
              exit 0
            fi
            
            if [ "$status" = "Ready" ] && [ "$health" = "Yellow" ]; then
              echo "⚠️ Deployment complete but health is Yellow"
              exit 0
            fi
            
            if [ "$health" = "Red" ]; then
              echo "❌ Deployment failed - Environment health is Red"
              echo "Recent events:"
              aws elasticbeanstalk describe-events \
                --application-name "${{ env.EB_APP_NAME }}" \
                --environment-name "${{ env.EB_ENV_NAME }}" \
                --max-items 10 \
                --region "${{ env.AWS_REGION }}"
              exit 1
            fi
            
            attempt=$((attempt + 1))
            echo "Waiting... ($attempt/$max_attempts)"
            sleep 20
          done
          
          echo "❌ Deployment timeout"
          exit 1

      - name: Output Environment URL
        if: success()
        run: |
          URL=$(aws elasticbeanstalk describe-environments \
            --application-name "${{ env.EB_APP_NAME }}" \
            --environment-names "${{ env.EB_ENV_NAME }}" \
            --query 'Environments[0].CNAME' --output text \
            --region "${{ env.AWS_REGION }}")
          echo "✅ Frontend URL: http://${URL}"